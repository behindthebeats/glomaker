///////////////////////////////////////////////////////////
//  Main.as
//  Macromedia ActionScript Implementation of the Class Main
//  Generated by Enterprise Architect
//  Created on:      06-Nov-2007 13:48:24
//  Original author: USER
///////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2007-09 LTRI, London Metropolitan Uni. All rights reserved.
// An Open Source Release under the GPL v3 licence  (see http://www.gnu.org/licenses/).
// Authors: Tom Boyle, Nils Millahn, Musbah Sagar, Martin Agombar.
// See http://www.glomaker.org for full details
/////////////////////////////////////////////////////////////////////////

package org.glomaker.patternmaker
{
	import flash.display.MovieClip;
	import flash.display.Shape;
	import flash.display.Sprite;
	import flash.events.*;
	
	import mx.controls.Alert;
	import mx.events.CloseEvent;
	
	import org.glomaker.interfaces.pattern.IPatternMakerBridge;
	import org.glomaker.patternmaker.controller.IPatternsController;
	import org.glomaker.patternmaker.controller.PatternsController;
	import org.glomaker.patternmaker.events.*;
	import org.glomaker.patternmaker.model.GloXML;
	import org.glomaker.patternmaker.model.IPatternsModel;
	import org.glomaker.patternmaker.view.*;

	/**
	 * @author USER
	 * @version 1.0
	 * @created 06-Nov-2007 13:48:24
	 */
	public class PatternMaker extends MovieClip implements IPatternMakerBridge {
		/**
		     * Document class for movie
		     */
		private var patternsModel:IPatternsModel;
		private var controller:IPatternsController;
		private var comboBox:CompositeView;

		private var filePath:String;
		
		private var _initialMenuData:Array;
		private var _initialNodeData:Array;
		
		private var _nodesWindow:ComponentView;
		

		public function PatternMaker()
		{
			// the SWF will be loaded into GLOMaker
			// we can only initialise the application once the 'stage' reference is available
			// so we set up a loop here to wait until that is the case
			addEventListener(Event.ENTER_FRAME, onEnterFrame);
		}
		
		
		/**
		 * Implements IPatternMakerBridge interface. 
		 * @return 
		 */		
		public function getPatternNodes():Array
		{
			if(!patternsModel)
				return [];
			
			return patternsModel.getNodeArray();
		}

		/**
		 * Updates data displayed in the PatternMaker. 
		 * Implements IPatternMakerBridge interface.
		 * @param library List of IPatternLibraryItem instances defining the left-hand-side function library.
		 * @param nodes List of nodes currently defined (IPatternNode instances)
		 * @param allowNodeEditing [optional, default: false] Allow the user to edit node label and description?
		 */		 
		public function updateData(library:Array, nodes:Array, allowNodeEditing:Boolean = false):void
		{
			if(patternsModel)
			{
				if(library && nodes)
				{
					patternsModel.setMenuAndNodes(library, nodes);
					patternsModel.nodeTitleEditing = allowNodeEditing;
				}
			}else{
				// model not yet available
				// save the data - it will be reapplied when the model is created
				_initialMenuData = library;
				_initialNodeData = nodes;
			}
		}
		 
		
		protected function onEnterFrame(evt:Event):void {
			
			// wait until stage reference is available
			if (stage == null)
				return;
			
			// waiting is over - remove listener
			removeEventListener(Event.ENTER_FRAME, onEnterFrame);
			
			// initialise
			init();
		}
		
		protected function init():void
		{
			patternsModel = new GloXML(this.stage);
			// patternsModel.setXML("xml/GLO_manifest.xml");

			controller = new PatternsController(patternsModel, this.stage);
			
			comboBox = new ComboBoxView(patternsModel, controller);
			addChild(comboBox);
			//comboBox.y = 10;
			comboBox.x = 180;
			comboBox.visible = true;

			patternsModel.addEventListener(ModelEvent.MODEL_EVENT, comboBox.update);
			
			_nodesWindow = new NodesWindow(patternsModel, this.stage, controller);
			_nodesWindow.x = 210;

			// add listeners for delete events so we can pass them on to glomaker for an Alert
			_nodesWindow.addEventListener( InteractiveNode.DELETE_ALL, onDeleteEvent );
			_nodesWindow.addEventListener( InteractiveNode.DELETE_NODE, onDeleteEvent );
			
			comboBox.add(_nodesWindow);

			var menu:ComponentView = new ScrollMenuView(patternsModel, controller);
			
			comboBox.add(menu);
			menu.y = 25;
			
			var divider:Shape = new Shape();
			divider.graphics.beginFill(0);
			divider.graphics.drawRect(0, 0, 1, 1000);
			divider.x = _nodesWindow.x;
			
			addChild(menu);
			addChild(_nodesWindow);
			addChild(divider);
			
			
			
			//addChild(connect);
			
			// if data was already set, apply it now
			if(_initialMenuData || _initialNodeData)
			{
				updateData(_initialMenuData, _initialNodeData);
				_initialMenuData = _initialNodeData = null;
			}
			
		}
		
		/**
		 * Triggers the alignment of connected nodes. 
		 * 
		 */
		public function alignNodes():void
		{
			(_nodesWindow as NodesWindow).alignNodes();
		}
		
		/**
		 * Set up printing. 
		 * 
		 */
		public function printSetup():void
		{
			(_nodesWindow as NodesWindow).printSetup();
		}
		
		/**
		 * Prints nodes. 
		 * 
		 */
		public function printNodes():void
		{
			(_nodesWindow as NodesWindow).printNodes();
		}
		
		
		// ************************************
		// Delete Alert handling workflow
		// ************************************
		
		protected var pendingDeleteEvent:Event;
		
		protected function onDeleteEvent(evt:Event):void
		{
			pendingDeleteEvent = evt;
			
			Alert.yesLabel = "Delete";
			Alert.noLabel = "Cancel";
			
			Alert.show( "Any corresponding data you have entered in Design Mode will also be deleted.\nAre you sure you want to continue?",
			"Confirm Delete",
			Alert.YES | Alert.NO, null, deleteAlertCloseHandler );	
		}
		
		protected function deleteAlertCloseHandler(evt:CloseEvent):void
		{
			if(evt.detail == Alert.YES)
			{
				switch( pendingDeleteEvent.type )
				{
					case InteractiveNode.DELETE_ALL:
						(controller  as  IPatternsController).removeAllNodes();
						break;
						
					case InteractiveNode.DELETE_NODE:
						(controller  as  IPatternsController).removeNode((pendingDeleteEvent.target as Sprite).name);
						break;
				}
				
				pendingDeleteEvent = null;
			}
		}
	}
}